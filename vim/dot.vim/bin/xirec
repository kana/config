#!/usr/bin/env gosh
; Misc.  ;{{{1
; Modules  ;{{{2

(use text.tree)
(use util.match)




(define (x->vson x)  ;{{{2
  ; Convert Scheme object X into a string which expresses an object in Vim
  ; script, i.e., Vim script object notation (VSON).
  (match x
    ((? integer? x) (x->string x))
    ((? string? x) (with-output-to-string (lambda () (write x))))
    ((? symbol? x) (symbol->string x))
    (('quote x) (x->string x))  ; FIXME: Need review.
    ; Other cases are not supported.
    ))








; Compiler  ;{{{1
(define (xire-compile x)  ;{{{2
  (match x
    ; FIXME: This dispatching is ad hoc.  It should be replaced with more
    ; sophisticated way and it should be easily extendable.  For example:
    ; (define-ex-command (echo (arg object) ...) ...)
    (('echo . args)
     (list :echo
           (map
             (lambda (x) (cons " " x))
             (map x->vson args))
           "\n")
     )
    (invalid-expression
     (errorf "~A:~A: Invalid expression: ~S"
       (port-name (current-input-port))
       (port-current-line (current-input-port))
       invalid-expression))
    ))








; Core  ;{{{1
(define (make-xire-context)  ;{{{2
  (let1 h (make-hash-table)
    (hash-table-put! h 'exprs (list))
    h))




(define (xire-emit context)  ;{{{2
  (write-tree (reverse (hash-table-get context 'exprs))))




(define (xire-push context x)  ;{{{2
  (hash-table-push! context 'exprs x))




(define (xire-translate)  ;{{{2
  (define context (make-xire-context))

  (port-for-each
    (lambda (x) (xire-push context (xire-compile x)))
    (lambda () (read)))

  (xire-emit context))








; Main  ;{{{1

(define (main args)
  (xire-translate)
  0)








; __END__  ;{{{1
; vim: filetype=scheme foldmethod=marker
